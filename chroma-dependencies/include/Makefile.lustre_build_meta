# Define the job/build that should be used for Lustre packages
JENKINS_JOB_NAME	:= lustre-b_ieel2_0
JENKINS_BUILD_NUMBER	:= 234
#JENKINS_JOB_NAME	:= lustre-b_ieel-reviews
#JENKINS_BUILD_NUMBER	:= 733

# Convoluted way of getting the directory this Makefile is in
INCLUDE_DIR		:= $(CURDIR)/$(dir $(lastword $(MAKEFILE_LIST)))
CHROMA_EXTERNALS_TOP	:= $(INCLUDE_DIR)/../../chroma-externals
LIB_DIR			:= ../lib
include $(INCLUDE_DIR)/Makefile.jenkins_meta

include $(INCLUDE_DIR)/Makefile.lustre_versions-$(DISTRO)

JENKINSAPI_VERSION 	:= $(shell ls $(CHROMA_EXTERNALS_TOP)/jenkinsapi-[0-9]*.tar.gz | sed 's/.*-\([0-9].*[0-9]\).*/\1/')

# The SHA1 of the Lustre tree release
RELEASE_SHA1 :=

ifneq ($(strip $(RELEASE_SHA1)),)
UNDERSCORE_RELEASE_POSTFIX	:= _$(RELEASE_SHA1)
DOT_RELEASE_POSTFIX		:= .$(RELEASE_SHA1)
endif

# it might be tempting to just make $(LIB_DIR)/jenkinsapi-$(JENKINSAPI_VERSION)
# a dependency of this rule but we don't want it's lack of presence on
# builders to force this target to get rebuilt so we unpack it inside the action
#$(INCLUDE_DIR)/Makefile.lustre_versions-$(DISTRO): $(call to-md5,$(INCLUDE_DIR)/Makefile.lustre_build_meta)
$(INCLUDE_DIR)/Makefile.lustre_versions-$(DISTRO): $(INCLUDE_DIR)/Makefile.lustre_build_meta.md5
	# any of this is only needed by make download
	if [ $(MAKECMDGOALS) != download ]; then                                                     \
	    touch $@;                                                                                \
	    exit 0;                                                                                  \
	fi;                                                                                          \
	if [ ! -d $(LIB_DIR)/jenkinsapi-$(JENKINSAPI_VERSION) ]; then                                \
	    mkdir -p $(LIB_DIR);                                                                     \
	    rm -rf $(LIB_DIR)/jenkinsapi-[0-9]*;                                                     \
	    tar -C $(LIB_DIR) -xzvf $(CHROMA_EXTERNALS_TOP)/jenkinsapi-$(JENKINSAPI_VERSION).tar.gz; \
	fi;                                                                                          \
	{ echo "# This file is automatically generated.  DO NOT update manually.";                   \
	echo "";                                                                                     \
	echo "LUSTRE_RELEASE := $(shell $(INCLUDE_DIR)/jenkinsapi $(JENKINS_ROOT_URL)                \
				  $(JENKINS_USERNAME) $(JENKINS_PASSWORD) $(JENKINS_JOB_NAME)        \
				  $(JENKINS_BUILD_NUMBER) $(DISTRO) get_lustre_ver)";                \
	echo "KERNEL_RELEASE := $(shell $(INCLUDE_DIR)/jenkinsapi $(JENKINS_ROOT_URL)                \
				  $(JENKINS_USERNAME) $(JENKINS_PASSWORD) $(JENKINS_JOB_NAME)        \
				  $(JENKINS_BUILD_NUMBER) $(DISTRO) get_lustre_kernel_ver)"; } > $@; \
	if git status --porcelain $@ | grep -q ^??; then                                             \
	    git add $@;                                                                              \
	fi

# this is how we cheat make into making stuff based not on which
# file is newer but based on whether file contents have changed.
# get the hash of a file.  if the the hash is the same as last time
# make the hash stamp file look really old so as not to trigger it's
# target to be [re-]created.  if the hash is different, freshen up
# the hash stamp file to make the file look very new causing it's
# target is recreated.
to-md5 = $(addsuffix .md5,$1)

%.md5: FORCE
	$(eval CHECKSUM := $(shell tr -d ' \n' < $* | md5sum))$(if $(filter-out $(shell cat $@ 2>/dev/null),$(CHECKSUM)),echo $(CHECKSUM) > $@)

FORCE:
